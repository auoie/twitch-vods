// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: queries.sql

package sqlvods

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteOldStreams = `-- name: DeleteOldStreams :exec
DELETE FROM streams
WHERE 
  start_time < $1
`

func (q *Queries) DeleteOldStreams(ctx context.Context, startTime time.Time) error {
	_, err := q.db.Exec(ctx, deleteOldStreams, startTime)
	return err
}

const deleteStreams = `-- name: DeleteStreams :exec
DELETE FROM streams
`

func (q *Queries) DeleteStreams(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteStreams)
	return err
}

const getAllBrotliBytesNotGzip = `-- name: GetAllBrotliBytesNotGzip :many
SELECT
  id, brotli_bytes
FROM
  streams
WHERE
  brotli_bytes IS NOT NULL AND gzipped_bytes IS NULL
`

type GetAllBrotliBytesNotGzipRow struct {
	ID          uuid.UUID
	BrotliBytes []byte
}

func (q *Queries) GetAllBrotliBytesNotGzip(ctx context.Context) ([]GetAllBrotliBytesNotGzipRow, error) {
	rows, err := q.db.Query(ctx, getAllBrotliBytesNotGzip)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBrotliBytesNotGzipRow
	for rows.Next() {
		var i GetAllBrotliBytesNotGzipRow
		if err := rows.Scan(&i.ID, &i.BrotliBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllGzippedBytesNotBrotli = `-- name: GetAllGzippedBytesNotBrotli :many
SELECT
  id, gzipped_bytes
FROM
  streams
WHERE
  gzipped_bytes IS NOT NULL AND brotli_bytes IS NULL
`

type GetAllGzippedBytesNotBrotliRow struct {
	ID           uuid.UUID
	GzippedBytes []byte
}

func (q *Queries) GetAllGzippedBytesNotBrotli(ctx context.Context) ([]GetAllGzippedBytesNotBrotliRow, error) {
	rows, err := q.db.Query(ctx, getAllGzippedBytesNotBrotli)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGzippedBytesNotBrotliRow
	for rows.Next() {
		var i GetAllGzippedBytesNotBrotliRow
		if err := rows.Scan(&i.ID, &i.GzippedBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEverything = `-- name: GetEverything :many
SELECT
  id, streamer_id, stream_id, start_time, max_views, last_updated_at, streamer_login_at_start, language_at_start, title_at_start, game_name_at_start, recording_fetched_at, gzipped_bytes, brotli_bytes, hls_domain, bytes_found, public, sub_only, seek_previews_domain
FROM
  streams s
`

func (q *Queries) GetEverything(ctx context.Context) ([]Stream, error) {
	rows, err := q.db.Query(ctx, getEverything)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stream
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.StreamerID,
			&i.StreamID,
			&i.StartTime,
			&i.MaxViews,
			&i.LastUpdatedAt,
			&i.StreamerLoginAtStart,
			&i.LanguageAtStart,
			&i.TitleAtStart,
			&i.GameNameAtStart,
			&i.RecordingFetchedAt,
			&i.GzippedBytes,
			&i.BrotliBytes,
			&i.HlsDomain,
			&i.BytesFound,
			&i.Public,
			&i.SubOnly,
			&i.SeekPreviewsDomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighestViewedLiveStreams = `-- name: GetHighestViewedLiveStreams :many
SELECT
  streamer_login_at_start, title_at_start, max_views, start_time, stream_id
FROM
  streams
WHERE
  bytes_found = $1 AND public = $2 AND language_at_start = $3
ORDER BY
  max_views DESC
LIMIT $4
`

type GetHighestViewedLiveStreamsParams struct {
	BytesFound      sql.NullBool
	Public          sql.NullBool
	LanguageAtStart string
	Limit           int32
}

type GetHighestViewedLiveStreamsRow struct {
	StreamerLoginAtStart string
	TitleAtStart         string
	MaxViews             int64
	StartTime            time.Time
	StreamID             string
}

func (q *Queries) GetHighestViewedLiveStreams(ctx context.Context, arg GetHighestViewedLiveStreamsParams) ([]GetHighestViewedLiveStreamsRow, error) {
	rows, err := q.db.Query(ctx, getHighestViewedLiveStreams,
		arg.BytesFound,
		arg.Public,
		arg.LanguageAtStart,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighestViewedLiveStreamsRow
	for rows.Next() {
		var i GetHighestViewedLiveStreamsRow
		if err := rows.Scan(
			&i.StreamerLoginAtStart,
			&i.TitleAtStart,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestLiveStreams = `-- name: GetLatestLiveStreams :many
SELECT
  id, stream_id, streamer_id, streamer_login_at_start, start_time, max_views, last_updated_at
FROM
  streams
WHERE
  last_updated_at >= $1 AND
  bytes_found IS NULL
`

type GetLatestLiveStreamsRow struct {
	ID                   uuid.UUID
	StreamID             string
	StreamerID           string
	StreamerLoginAtStart string
	StartTime            time.Time
	MaxViews             int64
	LastUpdatedAt        time.Time
}

func (q *Queries) GetLatestLiveStreams(ctx context.Context, lastUpdatedAt time.Time) ([]GetLatestLiveStreamsRow, error) {
	rows, err := q.db.Query(ctx, getLatestLiveStreams, lastUpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestLiveStreamsRow
	for rows.Next() {
		var i GetLatestLiveStreamsRow
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.StreamerID,
			&i.StreamerLoginAtStart,
			&i.StartTime,
			&i.MaxViews,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestStreams = `-- name: GetLatestStreams :many
SELECT
  id, stream_id, streamer_id, start_time, max_views, last_updated_at
FROM
  streams
ORDER BY
  last_updated_at DESC
LIMIT $1
`

type GetLatestStreamsRow struct {
	ID            uuid.UUID
	StreamID      string
	StreamerID    string
	StartTime     time.Time
	MaxViews      int64
	LastUpdatedAt time.Time
}

func (q *Queries) GetLatestStreams(ctx context.Context, limit int32) ([]GetLatestStreamsRow, error) {
	rows, err := q.db.Query(ctx, getLatestStreams, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestStreamsRow
	for rows.Next() {
		var i GetLatestStreamsRow
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.StreamerID,
			&i.StartTime,
			&i.MaxViews,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestStreamsFromStreamerId = `-- name: GetLatestStreamsFromStreamerId :many
SELECT
  id, last_updated_at, max_views, start_time, streamer_id, stream_id, streamer_login_at_start
FROM
  streams
WHERE
  streamer_id = $1
ORDER BY
  start_time DESC
LIMIT $2
`

type GetLatestStreamsFromStreamerIdParams struct {
	StreamerID string
	Limit      int32
}

type GetLatestStreamsFromStreamerIdRow struct {
	ID                   uuid.UUID
	LastUpdatedAt        time.Time
	MaxViews             int64
	StartTime            time.Time
	StreamerID           string
	StreamID             string
	StreamerLoginAtStart string
}

func (q *Queries) GetLatestStreamsFromStreamerId(ctx context.Context, arg GetLatestStreamsFromStreamerIdParams) ([]GetLatestStreamsFromStreamerIdRow, error) {
	rows, err := q.db.Query(ctx, getLatestStreamsFromStreamerId, arg.StreamerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestStreamsFromStreamerIdRow
	for rows.Next() {
		var i GetLatestStreamsFromStreamerIdRow
		if err := rows.Scan(
			&i.ID,
			&i.LastUpdatedAt,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamerID,
			&i.StreamID,
			&i.StreamerLoginAtStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestStreamsFromStreamerLogin = `-- name: GetLatestStreamsFromStreamerLogin :many
WITH
  goal_id AS
(SELECT
  streamer_id
FROM
  streams
WHERE
  streams.streamer_login_at_start = $1
ORDER BY
  start_time DESC
LIMIT 1)
SELECT
  id, last_updated_at, max_views, start_time, s.streamer_id, stream_id, streamer_login_at_start
FROM
  streams s
INNER JOIN
  goal_id
ON
  s.streamer_id = goal_id.streamer_id
ORDER BY
  start_time DESC
LIMIT $2
`

type GetLatestStreamsFromStreamerLoginParams struct {
	StreamerLoginAtStart string
	Limit                int32
}

type GetLatestStreamsFromStreamerLoginRow struct {
	ID                   uuid.UUID
	LastUpdatedAt        time.Time
	MaxViews             int64
	StartTime            time.Time
	StreamerID           string
	StreamID             string
	StreamerLoginAtStart string
}

func (q *Queries) GetLatestStreamsFromStreamerLogin(ctx context.Context, arg GetLatestStreamsFromStreamerLoginParams) ([]GetLatestStreamsFromStreamerLoginRow, error) {
	rows, err := q.db.Query(ctx, getLatestStreamsFromStreamerLogin, arg.StreamerLoginAtStart, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestStreamsFromStreamerLoginRow
	for rows.Next() {
		var i GetLatestStreamsFromStreamerLoginRow
		if err := rows.Scan(
			&i.ID,
			&i.LastUpdatedAt,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamerID,
			&i.StreamID,
			&i.StreamerLoginAtStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamBrotliBytes = `-- name: GetStreamBrotliBytes :many
SELECT
  brotli_bytes
FROM
  streams
WHERE
  stream_id = $1
LIMIT 1
`

func (q *Queries) GetStreamBrotliBytes(ctx context.Context, streamID string) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getStreamBrotliBytes, streamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var brotli_bytes []byte
		if err := rows.Scan(&brotli_bytes); err != nil {
			return nil, err
		}
		items = append(items, brotli_bytes)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamForEachStreamIdUnnest = `-- name: GetStreamForEachStreamIdUnnest :many
WITH
  ids AS (SELECT unnest($1::TEXT[]) AS stream_id)
SELECT
  id, last_updated_at, max_views, start_time, streamer_id, streams.stream_id, streamer_login_at_start
FROM 
  ids
LEFT JOIN
  streams
ON
  ids.stream_id = streams.stream_id
`

type GetStreamForEachStreamIdUnnestRow struct {
	ID                   uuid.NullUUID
	LastUpdatedAt        sql.NullTime
	MaxViews             sql.NullInt64
	StartTime            sql.NullTime
	StreamerID           sql.NullString
	StreamID             sql.NullString
	StreamerLoginAtStart sql.NullString
}

func (q *Queries) GetStreamForEachStreamIdUnnest(ctx context.Context, streamIDArr []string) ([]GetStreamForEachStreamIdUnnestRow, error) {
	rows, err := q.db.Query(ctx, getStreamForEachStreamIdUnnest, streamIDArr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStreamForEachStreamIdUnnestRow
	for rows.Next() {
		var i GetStreamForEachStreamIdUnnestRow
		if err := rows.Scan(
			&i.ID,
			&i.LastUpdatedAt,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamerID,
			&i.StreamID,
			&i.StreamerLoginAtStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamGzippedBytes = `-- name: GetStreamGzippedBytes :many
SELECT
  gzipped_bytes
FROM
  streams
WHERE
  stream_id = $1
LIMIT 1
`

func (q *Queries) GetStreamGzippedBytes(ctx context.Context, streamID string) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getStreamGzippedBytes, streamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var gzipped_bytes []byte
		if err := rows.Scan(&gzipped_bytes); err != nil {
			return nil, err
		}
		items = append(items, gzipped_bytes)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBrotliBytes = `-- name: SetBrotliBytes :exec
WITH 
  input_bytes AS
(SELECT
  unnest($1::UUID[]) AS id,
  unnest($2::BYTEA[]) AS brotli_bytes)
UPDATE
  streams
SET
  brotli_bytes = input_bytes.brotli_bytes
FROM
  input_bytes
WHERE
  streams.id = input_bytes.id
`

type SetBrotliBytesParams struct {
	IDArr          []uuid.UUID
	BrotliBytesArr [][]byte
}

func (q *Queries) SetBrotliBytes(ctx context.Context, arg SetBrotliBytesParams) error {
	_, err := q.db.Exec(ctx, setBrotliBytes, arg.IDArr, arg.BrotliBytesArr)
	return err
}

const setGzipBytes = `-- name: SetGzipBytes :exec
WITH 
  input_bytes AS
(SELECT
  unnest($1::UUID[]) AS id,
  unnest($2::BYTEA[]) AS gzip_bytes)
UPDATE
  streams
SET
  gzipped_bytes = input_bytes.gzip_bytes
FROM
  input_bytes
WHERE
  streams.id = input_bytes.id
`

type SetGzipBytesParams struct {
	IDArr        []uuid.UUID
	GzipBytesArr [][]byte
}

func (q *Queries) SetGzipBytes(ctx context.Context, arg SetGzipBytesParams) error {
	_, err := q.db.Exec(ctx, setGzipBytes, arg.IDArr, arg.GzipBytesArr)
	return err
}

const updateRecording = `-- name: UpdateRecording :exec
UPDATE
  streams
SET
  recording_fetched_at = $2,
  hls_domain = $3,
  gzipped_bytes = $4,
  bytes_found = $5,
  seek_previews_domain = $6,
  public = $7,
  sub_only = $8
WHERE
  stream_id = $1
`

type UpdateRecordingParams struct {
	StreamID           string
	RecordingFetchedAt sql.NullTime
	HlsDomain          sql.NullString
	GzippedBytes       []byte
	BytesFound         sql.NullBool
	SeekPreviewsDomain sql.NullString
	Public             sql.NullBool
	SubOnly            sql.NullBool
}

func (q *Queries) UpdateRecording(ctx context.Context, arg UpdateRecordingParams) error {
	_, err := q.db.Exec(ctx, updateRecording,
		arg.StreamID,
		arg.RecordingFetchedAt,
		arg.HlsDomain,
		arg.GzippedBytes,
		arg.BytesFound,
		arg.SeekPreviewsDomain,
		arg.Public,
		arg.SubOnly,
	)
	return err
}

const upsertManyStreams = `-- name: UpsertManyStreams :exec
INSERT INTO
  streams (last_updated_at, max_views, start_time, streamer_id, stream_id, streamer_login_at_start, game_name_at_start, language_at_start, title_at_start)
SELECT
  unnest($1::TIMESTAMP(3)[]) AS last_updated_at,
  unnest($2::BIGINT[]) AS max_views,
  unnest($3::TIMESTAMP(3)[]) AS start_time,
  unnest($4::TEXT[]) AS streamer_id,
  unnest($5::TEXT[]) AS stream_id,
  unnest($6::TEXT[]) AS streamer_login_at_start,
  unnest($7::TEXT[]) AS game_name_at_start,
  unnest($8::TEXT[]) AS language_at_start,
  unnest($9::TEXT[]) AS title_at_start
ON CONFLICT
  (stream_id)
DO
  UPDATE SET
    last_updated_at = EXCLUDED.last_updated_at,
    max_views = GREATEST(streams.max_views, EXCLUDED.max_views)
`

type UpsertManyStreamsParams struct {
	LastUpdatedAtArr        []time.Time
	MaxViewsArr             []int64
	StartTimeArr            []time.Time
	StreamerIDArr           []string
	StreamIDArr             []string
	StreamerLoginAtStartArr []string
	GameNameAtStartArr      []string
	LanguageAtStartArr      []string
	TitleAtStartArr         []string
}

func (q *Queries) UpsertManyStreams(ctx context.Context, arg UpsertManyStreamsParams) error {
	_, err := q.db.Exec(ctx, upsertManyStreams,
		arg.LastUpdatedAtArr,
		arg.MaxViewsArr,
		arg.StartTimeArr,
		arg.StreamerIDArr,
		arg.StreamIDArr,
		arg.StreamerLoginAtStartArr,
		arg.GameNameAtStartArr,
		arg.LanguageAtStartArr,
		arg.TitleAtStartArr,
	)
	return err
}
