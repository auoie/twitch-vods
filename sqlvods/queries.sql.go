// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: queries.sql

package sqlvods

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteStreams = `-- name: DeleteStreams :exec
DELETE FROM streams
`

func (q *Queries) DeleteStreams(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteStreams)
	return err
}

const getEverything = `-- name: GetEverything :many
SELECT
  id, streamer_id, stream_id, start_time, max_views, last_updated_at, streamer_login_at_start, language_at_start, title_at_start, game_name_at_start, recording_fetched_at, gzipped_bytes, hls_domain, bytes_found, public, sub_only, seek_previews_domain
FROM
  streams s
`

func (q *Queries) GetEverything(ctx context.Context) ([]Stream, error) {
	rows, err := q.db.Query(ctx, getEverything)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stream
	for rows.Next() {
		var i Stream
		if err := rows.Scan(
			&i.ID,
			&i.StreamerID,
			&i.StreamID,
			&i.StartTime,
			&i.MaxViews,
			&i.LastUpdatedAt,
			&i.StreamerLoginAtStart,
			&i.LanguageAtStart,
			&i.TitleAtStart,
			&i.GameNameAtStart,
			&i.RecordingFetchedAt,
			&i.GzippedBytes,
			&i.HlsDomain,
			&i.BytesFound,
			&i.Public,
			&i.SubOnly,
			&i.SeekPreviewsDomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestLiveStreams = `-- name: GetLatestLiveStreams :many
SELECT
  id, stream_id, streamer_id, streamer_login_at_start, start_time, max_views, last_updated_at
FROM
  streams
WHERE
  last_updated_at >= $1 AND
  bytes_found IS NULL
`

type GetLatestLiveStreamsRow struct {
	ID                   uuid.UUID
	StreamID             string
	StreamerID           string
	StreamerLoginAtStart string
	StartTime            time.Time
	MaxViews             int64
	LastUpdatedAt        time.Time
}

func (q *Queries) GetLatestLiveStreams(ctx context.Context, lastUpdatedAt time.Time) ([]GetLatestLiveStreamsRow, error) {
	rows, err := q.db.Query(ctx, getLatestLiveStreams, lastUpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestLiveStreamsRow
	for rows.Next() {
		var i GetLatestLiveStreamsRow
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.StreamerID,
			&i.StreamerLoginAtStart,
			&i.StartTime,
			&i.MaxViews,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestStreams = `-- name: GetLatestStreams :many
SELECT
  id, stream_id, streamer_id, start_time, max_views, last_updated_at
FROM
  streams
ORDER BY
  last_updated_at DESC
LIMIT $1
`

type GetLatestStreamsRow struct {
	ID            uuid.UUID
	StreamID      string
	StreamerID    string
	StartTime     time.Time
	MaxViews      int64
	LastUpdatedAt time.Time
}

func (q *Queries) GetLatestStreams(ctx context.Context, limit int32) ([]GetLatestStreamsRow, error) {
	rows, err := q.db.Query(ctx, getLatestStreams, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestStreamsRow
	for rows.Next() {
		var i GetLatestStreamsRow
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.StreamerID,
			&i.StartTime,
			&i.MaxViews,
			&i.LastUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestStreamsFromStreamerId = `-- name: GetLatestStreamsFromStreamerId :many
SELECT
  id, last_updated_at, max_views, start_time, streamer_id, stream_id, streamer_login_at_start
FROM
  streams
WHERE
  stream_id = $1
ORDER BY
  start_time DESC
LIMIT $2
`

type GetLatestStreamsFromStreamerIdParams struct {
	StreamID string
	Limit    int32
}

type GetLatestStreamsFromStreamerIdRow struct {
	ID                   uuid.UUID
	LastUpdatedAt        time.Time
	MaxViews             int64
	StartTime            time.Time
	StreamerID           string
	StreamID             string
	StreamerLoginAtStart string
}

func (q *Queries) GetLatestStreamsFromStreamerId(ctx context.Context, arg GetLatestStreamsFromStreamerIdParams) ([]GetLatestStreamsFromStreamerIdRow, error) {
	rows, err := q.db.Query(ctx, getLatestStreamsFromStreamerId, arg.StreamID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestStreamsFromStreamerIdRow
	for rows.Next() {
		var i GetLatestStreamsFromStreamerIdRow
		if err := rows.Scan(
			&i.ID,
			&i.LastUpdatedAt,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamerID,
			&i.StreamID,
			&i.StreamerLoginAtStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamByStreamId = `-- name: GetStreamByStreamId :one
SELECT 
  id, last_updated_at, max_views, start_time, streamer_id, stream_id, streamer_login_at_start
FROM
  streams
WHERE
  stream_id = $1
`

type GetStreamByStreamIdRow struct {
	ID                   uuid.UUID
	LastUpdatedAt        time.Time
	MaxViews             int64
	StartTime            time.Time
	StreamerID           string
	StreamID             string
	StreamerLoginAtStart string
}

func (q *Queries) GetStreamByStreamId(ctx context.Context, streamID string) (GetStreamByStreamIdRow, error) {
	row := q.db.QueryRow(ctx, getStreamByStreamId, streamID)
	var i GetStreamByStreamIdRow
	err := row.Scan(
		&i.ID,
		&i.LastUpdatedAt,
		&i.MaxViews,
		&i.StartTime,
		&i.StreamerID,
		&i.StreamID,
		&i.StreamerLoginAtStart,
	)
	return i, err
}

const getStreamForEachStreamId = `-- name: GetStreamForEachStreamId :many
SELECT
  id, last_updated_at, max_views, start_time, streamer_id, stream_id, streamer_login_at_start
FROM 
  streams
WHERE
  stream_id = ANY($1::TEXT[])
`

type GetStreamForEachStreamIdRow struct {
	ID                   uuid.UUID
	LastUpdatedAt        time.Time
	MaxViews             int64
	StartTime            time.Time
	StreamerID           string
	StreamID             string
	StreamerLoginAtStart string
}

func (q *Queries) GetStreamForEachStreamId(ctx context.Context, dollar_1 []string) ([]GetStreamForEachStreamIdRow, error) {
	rows, err := q.db.Query(ctx, getStreamForEachStreamId, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStreamForEachStreamIdRow
	for rows.Next() {
		var i GetStreamForEachStreamIdRow
		if err := rows.Scan(
			&i.ID,
			&i.LastUpdatedAt,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamerID,
			&i.StreamID,
			&i.StreamerLoginAtStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamForEachStreamIdUnnest = `-- name: GetStreamForEachStreamIdUnnest :many
WITH
  ids AS (SELECT unnest($1::TEXT[]) AS stream_id)
SELECT
  id, last_updated_at, max_views, start_time, streamer_id, streams.stream_id, streamer_login_at_start
FROM 
  ids
LEFT JOIN
  streams
ON
  ids.stream_id = streams.stream_id
`

type GetStreamForEachStreamIdUnnestRow struct {
	ID                   uuid.NullUUID
	LastUpdatedAt        sql.NullTime
	MaxViews             sql.NullInt64
	StartTime            sql.NullTime
	StreamerID           sql.NullString
	StreamID             sql.NullString
	StreamerLoginAtStart sql.NullString
}

func (q *Queries) GetStreamForEachStreamIdUnnest(ctx context.Context, streamIDArr []string) ([]GetStreamForEachStreamIdUnnestRow, error) {
	rows, err := q.db.Query(ctx, getStreamForEachStreamIdUnnest, streamIDArr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStreamForEachStreamIdUnnestRow
	for rows.Next() {
		var i GetStreamForEachStreamIdUnnestRow
		if err := rows.Scan(
			&i.ID,
			&i.LastUpdatedAt,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamerID,
			&i.StreamID,
			&i.StreamerLoginAtStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamsByStreamId = `-- name: GetStreamsByStreamId :many
SELECT 
  id, last_updated_at, max_views, start_time, streamer_id, stream_id, streamer_login_at_start
FROM
  streams
WHERE
  stream_id = $1
`

type GetStreamsByStreamIdRow struct {
	ID                   uuid.UUID
	LastUpdatedAt        time.Time
	MaxViews             int64
	StartTime            time.Time
	StreamerID           string
	StreamID             string
	StreamerLoginAtStart string
}

func (q *Queries) GetStreamsByStreamId(ctx context.Context, streamID string) ([]GetStreamsByStreamIdRow, error) {
	rows, err := q.db.Query(ctx, getStreamsByStreamId, streamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStreamsByStreamIdRow
	for rows.Next() {
		var i GetStreamsByStreamIdRow
		if err := rows.Scan(
			&i.ID,
			&i.LastUpdatedAt,
			&i.MaxViews,
			&i.StartTime,
			&i.StreamerID,
			&i.StreamID,
			&i.StreamerLoginAtStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecording = `-- name: UpdateRecording :exec
UPDATE
  streams
SET
  recording_fetched_at = $2,
  hls_domain = $3,
  gzipped_bytes = $4,
  bytes_found = $5,
  seek_previews_domain = $6,
  public = $7,
  sub_only = $8
WHERE
  stream_id = $1
`

type UpdateRecordingParams struct {
	StreamID           string
	RecordingFetchedAt sql.NullTime
	HlsDomain          sql.NullString
	GzippedBytes       []byte
	BytesFound         sql.NullBool
	SeekPreviewsDomain sql.NullString
	Public             sql.NullBool
	SubOnly            sql.NullBool
}

func (q *Queries) UpdateRecording(ctx context.Context, arg UpdateRecordingParams) error {
	_, err := q.db.Exec(ctx, updateRecording,
		arg.StreamID,
		arg.RecordingFetchedAt,
		arg.HlsDomain,
		arg.GzippedBytes,
		arg.BytesFound,
		arg.SeekPreviewsDomain,
		arg.Public,
		arg.SubOnly,
	)
	return err
}

const upsertManyStreams = `-- name: UpsertManyStreams :exec
INSERT INTO
  streams (last_updated_at, max_views, start_time, streamer_id, stream_id, streamer_login_at_start, game_name_at_start, language_at_start, title_at_start)
SELECT
  unnest($1::TIMESTAMP(3)[]) AS last_updated_at,
  unnest($2::BIGINT[]) AS max_views,
  unnest($3::TIMESTAMP(3)[]) AS start_time,
  unnest($4::TEXT[]) AS streamer_id,
  unnest($5::TEXT[]) AS stream_id,
  unnest($6::TEXT[]) AS streamer_login_at_start,
  unnest($7::TEXT[]) AS game_name_at_start,
  unnest($8::TEXT[]) AS language_at_start,
  unnest($9::TEXT[]) AS title_at_start
ON CONFLICT
  (stream_id)
DO
  UPDATE SET
    last_updated_at = EXCLUDED.last_updated_at,
    max_views = GREATEST(streams.max_views, EXCLUDED.max_views)
`

type UpsertManyStreamsParams struct {
	LastUpdatedAtArr        []time.Time
	MaxViewsArr             []int64
	StartTimeArr            []time.Time
	StreamerIDArr           []string
	StreamIDArr             []string
	StreamerLoginAtStartArr []string
	GameNameAtStartArr      []string
	LanguageAtStartArr      []string
	TitleAtStartArr         []string
}

func (q *Queries) UpsertManyStreams(ctx context.Context, arg UpsertManyStreamsParams) error {
	_, err := q.db.Exec(ctx, upsertManyStreams,
		arg.LastUpdatedAtArr,
		arg.MaxViewsArr,
		arg.StartTimeArr,
		arg.StreamerIDArr,
		arg.StreamIDArr,
		arg.StreamerLoginAtStartArr,
		arg.GameNameAtStartArr,
		arg.LanguageAtStartArr,
		arg.TitleAtStartArr,
	)
	return err
}
